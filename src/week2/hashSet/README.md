# 📅 Week 2-2: MyHashSet - 중복 없는 데이터 집합의 설계

### 1. 핵심 개념 리마인드
* **Set Interface**: 중복된 원소를 허용하지 않으며, 요소 간의 순서를 보장하지 않는 수학적 '집합' 자료구조.
* **Composition (합성)**: 처음부터 해시 로직을 새로 짜는 대신, 이미 구현된 `MyHashMap`을 내부 저장소로 활용하여 기능을 위임(Delegation).
* **Key 유일성 활용**: "Map의 Key는 중복될 수 없다"는 제약 조건을 이용해 데이터를 Key 자리에 저장하고 관리.

### 2. 주요 로직 구현 포인트
* **PRESENT 더미 객체**:
    - `HashMap`은 `Value`가 필수지만, `HashSet`은 데이터 자체가 곧 `Key`이므로 `Value` 값은 의미가 없음.
    - 불필요한 메모리 낭비를 막기 위해 단 하나의 `static final Object PRESENT = new Object();`를 생성하여 모든 노드가 공유하도록 설계.
* **중복 방지 메커니즘 (`add`)**:
    - `MyHashMap.put(key, value)`의 리턴값 활용: 신규 추가 시 `null`, 중복 키 존재 시 기존 `Value` 반환.
    - 리턴값이 `null`인 경우에만 추가 성공(`true`)으로 간주하여 데이터의 유일성을 보장.
* **조회 및 삭제의 효율성**:
    - `MyHashMap`에서 구현한 $O(1)$ 기반의 탐색 로직(`get`, `remove`)을 그대로 호출하여 최적의 성능 유지.



### 3. 메서드 분석 및 복잡도 ($O$)
| 메서드 | 역할 | 내부 동작 (Map 활용) | 시간 복잡도 |
| :--- | :--- | :--- | :---: |
| **`add(E e)`** | 요소 추가 | `map.put(e, PRESENT) == null` | $O(1)$ |
| **`remove(E e)`** | 요소 삭제 | `map.remove(e) != null` | $O(1)$ |
| **`contains(E e)`** | 존재 확인 | `map.get(e) != null` | $O(1)$ |
| **`size()`** | 개수 확인 | `map.size()` | $O(1)$ |

### 💡 Insight
"해시셋을 구현하며 **'자료구조의 재사용성'**에 대해 깊이 고찰했다. `HashMap`이 완벽하게 설계되어 있다면, 이를 감싸는(Wrapping) 것만으로도 강력한 기능을 가진 새로운 자료구조(`Set`)를 단 몇 줄의 코드로 탄생시킬 수 있었다. 1주차에 배운 **'추상화'**와 오늘 배운 **'합성'**이 실무에서 어떻게 코드의 안정성과 생산성을 높이는지 체감할 수 있었다."
