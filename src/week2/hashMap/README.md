## 📅 Day 2: HashMap (해시맵) - $O(1)$을 향한 설계

### 1. 핵심 개념 리마인드
* **Key-Value Pair**: 데이터를 키와 값의 쌍으로 관리하여, 특정 키를 통해 값을 즉시 찾아내는 구조.
* **Separate Chaining**: 해시 충돌(같은 인덱스 배정) 발생 시, 해당 버킷에 노드들을 연결 리스트(Linked List) 형태로 매달아 데이터를 보존하는 방식.
* **Hashing & Indexing**: 무한한 객체의 키를 유한한 배열의 인덱스로 압축 변환하는 매핑 과정.

### 2. 주요 로직 구현 포인트
* **저장소 설계 (Node Array)**: `Key`, `Value`, `next` 참조를 가진 `Node<K, V>` 클래스를 정의하고, 이를 담는 배열 `table`을 본체로 사용.
* **주요 메서드**:
    - `put(K key, V value)`: 키의 해시값을 인덱스로 계산하여 저장. 동일 키 존재 시 값을 업데이트하며, 충돌 시 리스트 끝에 노드 추가 ($O(1)$).
    - `get(K key)`: 인덱스로 즉시 접근 후, 연결 리스트를 순회하며 `equals()`로 실제 키를 대조해 반환 ($O(1)$).
    - `remove(K key)`: `prev` 노드를 유지하며 순회하다 타겟 발견 시 연결 고리를 건너뛰게 재설정하여 삭제 ($O(1)$).
* **Dynamic Resizing**: 데이터 개수가 용량의 75%(`Load Factor 0.75`)를 넘어서면 배열을 2배 확장하고 모든 노드를 새 위치에 재배치(Rehashing).



### 3. 시간 복잡도 분석 ($O$)
| 연산 | 복잡도 | 이유 |
| :--- | :--- | :--- |
| **put** | $O(1)$ | 해시 함수를 통해 인덱스로 즉시 접근 (평균) |
| **get** | $O(1)$ | 인덱스 계산 후 바로 데이터 추출 (평균) |
| **remove** | $O(1)$ | 인덱스 접근 후 노드 포인터만 변경 (평균) |
| **resize** | $O(n)$ | 기존 모든 데이터를 새로운 인덱스로 다시 계산하여 이동 |

### 💡 Insight
"해시 충돌은 피할 수 없는 필연임을 인정하고, 이를 어떻게 관리하느냐가 해시 자료구조의 핵심임을 배웠다. 특히 배열 크기가 변할 때 인덱스 산출 기준이 달라지는 문제를 해결하기 위한 **Rehashing**의 필요성과, 시간(탐색 속도)과 공간(메모리 활용도) 사이의 균형점인 **0.75의 법칙**을 통해 엔지니어링적 타협의 중요성을 깨달았다."