# 🏁 WEEK1: 선형 자료구조 (Linear Data Structures) 완벽 정복

1주차에는 데이터를 저장하고 관리하는 가장 기초적이면서도 중요한 **선형 자료구조**들을 밑바닥부터 직접 구현하며 각 구조의 메커니즘과 효율성을 학습했습니다.

## 📌 학습 로드맵
1. **ArrayList**: 동적 배열의 원리와 메모리 연속성 학습
2. **LinkedList**: 노드와 참조를 이용한 데이터 연결 원리 학습
3. **Stack**: LIFO(후입선출) 질서와 ArrayList의 활용
4. **Queue**: FIFO(선입선출) 질서와 LinkedList의 최적화

---

## 📊 자료구조별 특징 및 시간 복잡도 ($O$)

| 자료구조 | 조회(Get) | 삽입/삭제(끝) | 삽입/삭제(앞/중간) | 장점 | 단점 |
| :--- | :---: | :---: | :---: | :--- | :--- |
| **ArrayList** | $O(1)$ | $O(1)$ | $O(n)$ | 빠른 인덱스 접근 | 중간 삽입/삭제 시 시프팅 비용 발생 |
| **LinkedList** | $O(n)$ | $O(1)$ | $O(1)^*$ | 삽입/삭제 시 연결만 변경 | 탐색 비용이 높음 |
| **Stack** | - | $O(1)$ | - | 데이터 역순 처리 최적화 | 중간 데이터 접근 불가 |
| **Queue** | - | $O(1)$ | - | 데이터 순차 처리 최적화 | 중간 데이터 접근 불가 |

> *LinkedList의 중간 삽입/삭제는 탐색 비용($O(n)$)을 제외한 순수 연결 변경 시간 기준입니다.

---

## 💡 주요 기술적 의사결정 (Key Decisions)

### 1. 왜 Stack은 ArrayList를 사용했는가?
스택은 항상 리스트의 **맨 뒤(Top)**에서만 데이터가 오갑니다. 배열 기반 리스트는 마지막 인덱스 접근이 $O(1)$이며, 메모리가 연속적이어서 CPU 캐시 효율이 높기 때문에 스택 구현에 가장 적합합니다.

### 2. 왜 Queue는 LinkedList를 사용했는가?
큐는 맨 뒤에서 넣고 **맨 앞(Head)**에서 뺍니다. `ArrayList`로 구현 시 맨 앞 데이터를 지울 때마다 전체 데이터를 한 칸씩 당기는 $O(n)$의 시프팅 비용이 발생합니다. 반면 `LinkedList`는 헤드 참조만 바꾸면 되므로 $O(1)$로 처리가 가능하여 압도적으로 효율적입니다.

### 3. Tail(last) 참조의 최적화
단순한 `LinkedList`에서 `add()`는 마지막 노드까지 순회해야 하므로 $O(n)$이 걸리지만, 마지막 노드를 가리키는 `last` 변수를 상시 유지함으로써 모든 삽입 연산을 $O(1)$로 최적화했습니다.

---

## 🔥 핵심 인사이트
> "자료구조의 '성능'은 고정된 절대값이 아니라, **데이터를 다루는 방식(질서)과 내부 저장소의 특성이 얼마나 잘 맞아떨어지느냐**에 결정된다. 개발자는 상황에 따라 메모리 효율과 시간 복잡도 사이의 최적의 트레이드오프(Trade-off)를 선택할 수 있어야 한다."

---

## 🛠️ 포함된 파일
- `arraylist/`: 동적 배열 구현 및 Resizing 로직
- `linkedlist/`: 단방향 연결 리스트 및 노드 관리
- `stack/`: LIFO 구조 및 ArrayList 위임 구현
- `queue/`: FIFO 구조 및 LinkedList 위임 구현