## 📅 Day 3: Queue (큐) - 선입선출(FIFO)의 설계

### 1. 핵심 개념 리마인드
* **FIFO (First-In-First-Out)**: 가장 먼저 들어온 데이터가 가장 먼저 나가는 대기열 구조.
* **LinkedList의 재발견**: 큐의 핵심인 '맨 앞 데이터 삭제'를 가장 효율적으로 처리할 수 있는 `MyLinkedList`를 내부 저장소로 채택.

### 2. 주요 로직 구현 포인트
* **저장소 선택 (LinkedList)**:
    - `ArrayList`로 큐를 구현할 경우, 맨 앞 삭제 시 모든 데이터를 한 칸씩 당기는 $O(n)$의 비용이 발생함.
    - 반면 `LinkedList`는 헤드 노드의 참조만 변경하면 되므로 $O(1)$로 처리가 가능하여 큐 구현에 훨씬 유리함.
* **주요 메서드**:
    - `offer(E item)`: 리스트의 끝(Tail)에 데이터를 추가 ($O(1)$).
    - `poll()`: 리스트의 첫 번째(Head) 노드를 제거하고 데이터를 반환 ($O(1)$).
    - `peek()`: 맨 앞 노드의 데이터를 확인.

### 3. 시간 복잡도 분석 ($O$)
| 연산 | 복잡도 | 이유 |
| :--- | :--- | :--- |
| **offer** | $O(1)$ | LinkedList의 `last` 참조를 이용한 즉시 추가 |
| **poll** | $O(1)$ | Head 노드 교체만으로 삭제 완료 (데이터 이동 없음) |
| **peek** | $O(1)$ | Head 노드 데이터 즉시 조회 |

### 💡 Insight
"큐를 구현하며 왜 `LinkedList`가 중요한지 비로소 체감했다. $O(n)$과 $O(1)$의 차이는 데이터가 많아질수록 시스템 전체 성능에 결정적인 영향을 미친다는 점을 확인했다. 상황에 맞는 적절한 저장소(List) 선택이 곧 알고리즘의 최적화임을 배웠다."