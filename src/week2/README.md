# 🏁 WEEK2: 해싱과 우선순위 (Hashing & Priority Structures)

2주차에는 데이터의 저장 위치를 직접 계산하여 검색 속도를 극대화하는 **해싱(Hashing)** 기법과, 비선형 구조를 통해 효율적으로 우선순위를 관리하는 **힙(Heap)**을 학습하며 자료구조의 성능 최적화를 경험했습니다.

## 📌 학습 로드맵
1. **MyHashMap**: `hashCode()`와 배열 인덱스를 매핑하여 $O(1)$ 접근 구현
2. **Separate Chaining**: 해시 충돌 발생 시 단방향 연결 리스트로 데이터를 연결하는 전략 학습
3. **MyHashSet**: `MyHashMap`을 내부 저장소로 활용하여 중복 없는 집합 자료구조 구현
4. **Priority Queue**: `ArrayList`를 완전 이진 트리로 해석하여 우선순위 데이터 정렬

---

## 📊 자료구조별 특징 및 시간 복잡도 ($O$)

| 자료구조 | 주요 연산 | 시간 복잡도 | 특징 |
| :--- | :--- | :---: | :--- |
| **MyHashMap** | `put()`, `get()` | $O(1)^*$ | Key를 인덱스로 변환하여 즉각적인 데이터 조회 |
| **MyHashSet** | `add()`, `contains()`| $O(1)^*$ | 내부적으로 Map의 Key 특징을 이용해 중복 제거 |
| **Priority Queue**| `add()`, `poll()` | $O(\log n)$ | 힙(Heap) 구조를 이용한 효율적인 서열 정리 |

> *해시 자료구조의 $O(1)$은 평균적인 경우이며, 충돌이 잦아 리스트가 길어질 경우 최악 $O(n)$까지 저하될 수 있음.

---

## 💡 주요 기술적 의사결정 (Key Decisions)

### 1. 해시 충돌 해결: Separate Chaining (Node<K, V> 구조)
해시 함수 결과가 같은 인덱스에 중복 배치될 경우를 대비해, 각 버킷을 `Node` 클래스의 연결 리스트 형태로 설계했습니다. `put()` 호출 시 기존 키가 존재하면 값을 업데이트하고, 없으면 리스트의 끝에 새 노드를 연결하여 데이터를 유연하게 수용합니다.


### 2. 동적 성능 유지: Load Factor & Resize
해시 테이블의 데이터가 많아질수록 충돌 확률이 높아져 성능이 $O(n)$에 수렴하게 됩니다. 이를 방지하기 위해 **Load Factor(0.75)** 기준을 도입, 데이터 점유율이 75%를 넘어서면 배열의 크기를 2배로 늘리고 기존 데이터를 재배치(`resize()`)하여 탐색 성능을 유지했습니다.

### 3. 상속 대신 위임 (Composition): HashSet의 설계
`MyHashSet`은 직접 데이터를 관리하는 대신, 이미 검증된 `MyHashMap`의 인스턴스를 내부 필드로 가집니다. 데이터는 Map의 `Key`에 저장하고, `Value`에는 더미 객체(`PRESENT`)를 할당함으로써 Map의 **'Key 중복 불가'** 특성을 완벽하게 재사용했습니다.
> **"map.put(e, PRESENT) == null"** 로직을 통해 추가 성공 여부를 Boolean으로 반환하는 깔끔한 설계 달성.

### 4. 힙(Heap)의 느슨한 정렬과 인덱스 연산
트리 노드 객체를 생성하는 대신 `ArrayList`를 활용하여 메모리 효율을 높였습니다. 부모와 자식 간의 관계를 `(i-1)/2`, `i*2 + 1` 등의 수식으로 해결함으로써 포인터 연산 없이도 $O(\log n)$의 성능을 보장했습니다.


---

## 🔥 핵심 인사이트
> "이번 주차의 핵심은 **'검증된 모듈의 재사용'**과 **'성능과 공간의 트레이드오프'**였다. HashMap을 통해 검색 성능을 극한으로 끌어올리는 법을 배웠고, HashSet을 구현하며 직접 만드는 것보다 잘 만들어진 구조를 '어떻게 활용(Composition)하느냐'가 설계의 완성도를 결정한다는 것을 깨달았다."

---

## 🛠️ 포함된 파일
- `hashMap/`: `Node` 연결 리스트와 해시 함수, `resize` 로직이 담긴 Map 구현체
- `hashSet/`: `MyHashMap`을 활용한 집합 자료구조 구현체
- `priorityQueue/`: 최소 힙(Min-Heap) 기반의 우선순위 큐 구현체