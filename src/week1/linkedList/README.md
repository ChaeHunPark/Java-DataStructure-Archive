## 📅 Week 1-2: LinkedList의 설계와 연결 구조

### 1. 핵심 개념 리마인드
* **논리적 연속성**: 데이터가 메모리 상에 흩어져 있어도 **참조(Reference)**를 통해 체인처럼 연결됨.
* **Node 설계**: 데이터(`item`)와 다음 노드의 주소(`next`)를 담는 리스트의 최소 단위 구현.
* **Head & Tail 최적화**: 시작점(`first`)과 끝점(`last`)을 동시에 관리하여 맨 뒤 삽입 성능을 최적화.

### 2. 주요 로직 구현 포인트
* **Node Traversal (node 메서드)**: 인덱스 접근을 위해 `first`부터 `index`까지 순차적으로 화살표를 타고 이동 ($O(n)$).
* **Pointer Manipulation (연결 수정)**:
    * **삽입**: 이전 노드의 `next`를 새 노드로, 새 노드의 `next`를 기존 다음 노드로 연결.
    * **삭제**: 이전 노드의 `next`를 다음 노드로 바로 건너뛰게 하여 중간 노드를 고립시킴.
* **Edge Case Handling (트러블슈팅)**:
    * **맨 앞/뒤 삭제**: `index == 0`일 때 `first` 갱신, `nextNode == null`일 때 `last` 갱신 로직을 통해 리스트의 무결성 유지.
    * **유일 노드 삭제**: 요소가 하나인 리스트를 비울 때 `first`와 `last`가 모두 `null`이 되도록 설계.
* **GC Friendly**: 삭제된 노드의 내부 참조(`next`, `item`)를 `null`로 초기화하여 가비지 컬렉터의 메모리 회수 효율 증대.

### 3. 시간 복잡도 분석 ($O$)
| 연산 | 복잡도 | 이유 |
| :--- | :--- | :--- |
| **조회 (get)** | $O(n)$ | 원하는 인덱스까지 노드를 하나씩 타고 들어가야 함. |
| **맨 뒤 추가 (add)** | $O(1)$ | `last` 참조를 통해 즉시 접근 및 연결. |
| **맨 앞 삽입/삭제** | $O(1)$ | `first` 참조만 변경하면 되므로 시프팅 비용 없음. |
| **중간 삽입/삭제** | $O(n)$ | 해당 인덱스까지 이동하는 탐색 비용이 지배적. |

### 🛠️ 구현 결과물
* **MyLinkedList.java**: 노드 기반 연결 리스트 로직 완성.
* **MyLinkedListTest.java**: 맨 앞/중간/맨 뒤 삭제 및 추가 예외 케이스 검증 완료.

### 💡 Insight
"단순히 '연결 리스트는 삽입/삭제가 빠르다'고만 알고 있었는데, 직접 구현해 보니 **탐색(`node(index)`) 과정이 포함되면 결국 $O(n)$이 걸린다**는 점을 명확히 깨달았다. 특히 `last` 노드를 관리하지 않았을 때의 성능 저하와, 삭제 시 `last` 참조를 이전 노드로 옮겨주는 예외 처리의 디테일이 `LinkedList` 구현의 핵심임을 배웠다."